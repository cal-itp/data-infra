WITH source AS (
    SELECT * FROM {{ source('external_enghouse', 'pay_windows') }}
),

clean_columns AS (
    SELECT
        {{ trim_make_empty_string_null('id') }} AS id,
        {{ trim_make_empty_string_null('token') }} AS token,
        {{ safe_cast('amount_settled', type_numeric()) }} AS amount_settled,
        {{ safe_cast('amount_to_settle', type_numeric()) }} AS amount_to_settle,
        {{ safe_cast('debt_settled', type_numeric()) }} AS debt_settled,
        {{ trim_make_empty_string_null('stage') }} AS stage,
        {{ trim_make_empty_string_null('vs') }} AS vs,
        {{ trim_make_empty_string_null('terminal_id') }} AS terminal_id,
        {{ safe_cast('open_date', type_timestamp()) }} AS open_date,
        {{ safe_cast('close_date', type_timestamp()) }} AS close_date,
        CAST(_line_number AS INTEGER) AS _line_number,
        `instance`,
        extract_filename,
        -- revisit the use of this littlepay-specific macro
        {{ extract_littlepay_filename_ts() }} AS enghouse_export_ts,
        {{ extract_littlepay_filename_date() }} AS enghouse_export_date,
        ts,
        -- hash all content not generated by us to enable deduping full dup rows
        -- hashing at this step will preserve distinction between nulls and empty strings in case that is meaningful upstream
        {{ dbt_utils.generate_surrogate_key(['id', 'token', 'amount_settled', 'amount_to_settle',
            'debt_settled', 'stage', 'vs', 'terminal_id', 'open_date', 'close_date']) }} AS _content_hash,
    FROM source
),

stg_enghouse__pay_windows AS (
    SELECT
        id,
        token,
        amount_settled,
        amount_to_settle,
        debt_settled,
        stage,
        vs,
        terminal_id,
        open_date,
        close_date,
         _line_number,
        `instance`,
        extract_filename,
        enghouse_export_ts,
        enghouse_export_date,
        ts,
        -- _key,
        -- _payments_key,
        _content_hash,
    FROM clean_columns
)

SELECT * FROM stg_enghouse__pay_windows
