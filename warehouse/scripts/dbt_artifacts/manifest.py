# generated by datamodel-codegen:
#   filename:  https://schemas.getdbt.com/dbt/manifest/v9.json
#   timestamp: 2023-05-15T18:21:34+00:00

from __future__ import annotations

from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Extra, Field


class UserIdItem(BaseModel):
    class Config:
        extra = Extra.allow

    __root__: str = Field(
        ..., regex="[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"
    )


class ManifestMetadata(BaseModel):
    class Config:
        extra = Extra.allow

    dbt_schema_version: Optional[str] = (
        "https://schemas.getdbt.com/dbt/manifest/v9.json"
    )
    dbt_version: Optional[str] = "1.6.0a1"
    generated_at: Optional[datetime] = "2023-04-21T11:09:06.496436Z"
    invocation_id: Optional[str] = "c4b245be-8edb-4ad7-ba54-9337ce594f5d"
    env: Optional[Dict[str, str]] = {}
    project_id: Optional[str] = Field(
        None, description="A unique identifier for the project"
    )
    user_id: Optional[UserIdItem] = Field(
        None, description="A unique identifier for the user"
    )
    send_anonymous_usage_stats: Optional[bool] = Field(
        None, description="Whether dbt is configured to send anonymous usage statistics"
    )
    adapter_type: Optional[str] = Field(
        None, description="The type name of the adapter"
    )


class ResourceType(Enum):
    analysis = "analysis"


class FileHash(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    checksum: str


class Hook(BaseModel):
    class Config:
        extra = Extra.allow

    sql: str
    transaction: Optional[bool] = True
    index: Optional[int] = None


class Docs(BaseModel):
    class Config:
        extra = Extra.allow

    show: Optional[bool] = True
    node_color: Optional[str] = None


class ContractConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enforced: Optional[bool] = False


class Type(Enum):
    check = "check"
    not_null = "not_null"
    unique = "unique"
    primary_key = "primary_key"
    foreign_key = "foreign_key"
    custom = "custom"


class ColumnLevelConstraint(BaseModel):
    class Config:
        extra = Extra.allow

    type: Type
    name: Optional[str] = None
    expression: Optional[str] = None
    warn_unenforced: Optional[bool] = True
    warn_unsupported: Optional[bool] = True


class RefArgs(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    package: Optional[str] = None
    version: Optional[Union[str, float]] = None


class DependsOn(BaseModel):
    class Config:
        extra = Extra.allow

    macros: Optional[List[str]] = []
    nodes: Optional[List[str]] = []


class InjectedCTE(BaseModel):
    class Config:
        extra = Extra.allow

    id: str
    sql: str


class Contract(BaseModel):
    class Config:
        extra = Extra.allow

    enforced: Optional[bool] = False
    checksum: Optional[str] = None


class ResourceType1(Enum):
    test = "test"


class TestConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True
    alias: Optional[str] = None
    schema_: Optional[str] = Field("dbt_test__audit", alias="schema")
    database: Optional[str] = None
    tags: Optional[Union[List[str], str]] = []
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    materialized: Optional[str] = "test"
    severity: Optional[str] = Field(
        "ERROR", regex="^([Ww][Aa][Rr][Nn]|[Ee][Rr][Rr][Oo][Rr])$"
    )
    store_failures: Optional[bool] = None
    where: Optional[str] = None
    limit: Optional[int] = None
    fail_calc: Optional[str] = "count(*)"
    warn_if: Optional[str] = "!= 0"
    error_if: Optional[str] = "!= 0"


class ResourceType2(Enum):
    operation = "operation"


class ResourceType3(Enum):
    model = "model"


class Access(Enum):
    protected = "protected"
    private = "private"
    public = "public"


class ModelLevelConstraint(BaseModel):
    class Config:
        extra = Extra.allow

    type: Type
    name: Optional[str] = None
    expression: Optional[str] = None
    warn_unenforced: Optional[bool] = True
    warn_unsupported: Optional[bool] = True
    columns: Optional[List[str]] = []


class ResourceType4(Enum):
    rpc = "rpc"


class ResourceType5(Enum):
    sql_operation = "sql operation"


class ResourceType6(Enum):
    test = "test"


class TestMetadata(BaseModel):  # type: ignore[no-redef]
    class Config:
        extra = Extra.allow

    name: str
    kwargs: Optional[Dict[str, Any]] = {}
    namespace: Optional[str] = None


class ResourceType7(Enum):
    snapshot = "snapshot"


class SnapshotConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True
    alias: Optional[str] = None
    schema_: Optional[str] = Field(None, alias="schema")
    database: Optional[str] = None
    tags: Optional[Union[List[str], str]] = []
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    materialized: Optional[str] = "snapshot"
    incremental_strategy: Optional[str] = None
    persist_docs: Optional[Dict[str, Any]] = {}
    post_hook: Optional[List[Hook]] = Field([], alias="post-hook")
    pre_hook: Optional[List[Hook]] = Field([], alias="pre-hook")
    quoting: Optional[Dict[str, Any]] = {}
    column_types: Optional[Dict[str, Any]] = {}
    full_refresh: Optional[bool] = None
    unique_key: Optional[str] = None
    on_schema_change: Optional[str] = "ignore"
    grants: Optional[Dict[str, Any]] = {}
    packages: Optional[List[str]] = []
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    contract: Optional[ContractConfig] = Field(
        default_factory=lambda: ContractConfig.parse_obj({"enforced": False})
    )
    strategy: Optional[str] = None
    target_schema: Optional[str] = None
    target_database: Optional[str] = None
    updated_at: Optional[str] = None
    check_cols: Optional[Union[str, List[str]]] = None


class ResourceType8(Enum):
    seed = "seed"


class SeedConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True
    alias: Optional[str] = None
    schema_: Optional[str] = Field(None, alias="schema")
    database: Optional[str] = None
    tags: Optional[Union[List[str], str]] = []
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    materialized: Optional[str] = "seed"
    incremental_strategy: Optional[str] = None
    persist_docs: Optional[Dict[str, Any]] = {}
    post_hook: Optional[List[Hook]] = Field([], alias="post-hook")
    pre_hook: Optional[List[Hook]] = Field([], alias="pre-hook")
    quoting: Optional[Dict[str, Any]] = {}
    column_types: Optional[Dict[str, Any]] = {}
    full_refresh: Optional[bool] = None
    unique_key: Optional[Union[str, List[str]]] = None
    on_schema_change: Optional[str] = "ignore"
    grants: Optional[Dict[str, Any]] = {}
    packages: Optional[List[str]] = []
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    contract: Optional[ContractConfig] = Field(
        default_factory=lambda: ContractConfig.parse_obj({"enforced": False})
    )
    quote_columns: Optional[bool] = None


class MacroDependsOn(BaseModel):
    class Config:
        extra = Extra.allow

    macros: Optional[List[str]] = []


class ResourceType9(Enum):
    source = "source"


class Quoting(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[bool] = None
    schema_: Optional[bool] = Field(None, alias="schema")
    identifier: Optional[bool] = None
    column: Optional[bool] = None


class FreshnessMetadata(BaseModel):
    class Config:
        extra = Extra.allow

    dbt_schema_version: Optional[str] = "https://schemas.getdbt.com/dbt/sources/v3.json"
    dbt_version: Optional[str] = "1.6.0a1"
    generated_at: Optional[datetime] = "2023-04-21T11:09:06.494387Z"
    invocation_id: Optional[str] = "c4b245be-8edb-4ad7-ba54-9337ce594f5d"
    env: Optional[Dict[str, str]] = {}


class Status(Enum):
    runtime_error = "runtime error"


class SourceFreshnessRuntimeError(BaseModel):
    class Config:
        extra = Extra.allow

    unique_id: str
    error: Optional[Union[str, int]] = None
    status: Status


class Status1(Enum):
    pass_ = "pass"
    warn = "warn"
    error = "error"
    runtime_error = "runtime error"


class PeriodEnum(Enum):
    minute = "minute"
    hour = "hour"
    day = "day"


class Time(BaseModel):
    class Config:
        extra = Extra.allow

    count: Optional[int] = None
    period: Optional[PeriodEnum] = None


class TimingInfo(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None


class ExternalPartition(BaseModel):
    class Config:
        extra = Extra.allow

    name: Optional[str] = ""
    description: Optional[str] = ""
    data_type: Optional[str] = ""
    meta: Optional[Dict[str, Any]] = {}


class SourceConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True


class ResourceType10(Enum):
    macro = "macro"


class SupportedLanguage(Enum):
    python = "python"
    sql = "sql"


class MacroArgument(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    type: Optional[str] = None
    description: Optional[str] = ""


class ResourceType11(Enum):
    doc = "doc"


class Documentation(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    resource_type: ResourceType11
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    block_contents: str


class ResourceType12(Enum):
    exposure = "exposure"


class Type2(Enum):
    dashboard = "dashboard"
    notebook = "notebook"
    analysis = "analysis"
    ml = "ml"
    application = "application"


class MaturityEnum(Enum):
    low = "low"
    medium = "medium"
    high = "high"


class Owner(BaseModel):
    class Config:
        extra = Extra.allow

    email: Optional[str] = None
    name: Optional[str] = None


class ExposureConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True


class ResourceType13(Enum):
    metric = "metric"


class MetricFilter(BaseModel):
    class Config:
        extra = Extra.allow

    field: str
    operator: str
    value: str


class PeriodEnum1(Enum):
    day = "day"
    week = "week"
    month = "month"
    year = "year"


class MetricTime(BaseModel):
    class Config:
        extra = Extra.allow

    count: Optional[int] = None
    period: Optional[PeriodEnum1] = None


class MetricConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True
    group: Optional[str] = None


class ResourceType14(Enum):
    group = "group"


class Group(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    resource_type: ResourceType14
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    owner: Owner


class NodeConfig(BaseModel):
    class Config:
        extra = Extra.allow

    enabled: Optional[bool] = True
    alias: Optional[str] = None
    schema_: Optional[str] = Field(None, alias="schema")
    database: Optional[str] = None
    tags: Optional[Union[List[str], str]] = []
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    materialized: Optional[str] = "view"
    incremental_strategy: Optional[str] = None
    persist_docs: Optional[Dict[str, Any]] = {}
    post_hook: Optional[List[Hook]] = Field([], alias="post-hook")
    pre_hook: Optional[List[Hook]] = Field([], alias="pre-hook")
    quoting: Optional[Dict[str, Any]] = {}
    column_types: Optional[Dict[str, Any]] = {}
    full_refresh: Optional[bool] = None
    unique_key: Optional[Union[str, List[str]]] = None
    on_schema_change: Optional[str] = "ignore"
    grants: Optional[Dict[str, Any]] = {}
    packages: Optional[List[str]] = []
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    contract: Optional[ContractConfig] = Field(
        default_factory=lambda: ContractConfig.parse_obj({"enforced": False})
    )


class ColumnInfo(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    description: Optional[str] = ""
    meta: Optional[Dict[str, Any]] = {}
    data_type: Optional[str] = None
    constraints: Optional[List[ColumnLevelConstraint]] = []
    quote: Optional[bool] = None
    tags: Optional[List[str]] = []


class SingularTestNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType1
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[TestConfig] = Field(
        default_factory=lambda: TestConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": "dbt_test__audit",
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "test",
                "severity": "ERROR",
                "store_failures": None,
                "where": None,
                "limit": None,
                "fail_calc": "count(*)",
                "warn_if": "!= 0",
                "error_if": "!= 0",
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.499299
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )


class HookNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType2
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[NodeConfig] = Field(
        default_factory=lambda: NodeConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "view",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.4999008
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )
    index: Optional[int] = None


class ModelNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType3
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[NodeConfig] = Field(
        default_factory=lambda: NodeConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "view",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.500488
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )
    access: Optional[Access] = "protected"
    constraints: Optional[List[ModelLevelConstraint]] = []
    version: Optional[Union[str, float]] = None
    latest_version: Optional[Union[str, float]] = None


class RPCNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType4
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[NodeConfig] = Field(
        default_factory=lambda: NodeConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "view",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.50125
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )


class SqlNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType5
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[NodeConfig] = Field(
        default_factory=lambda: NodeConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "view",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.501826
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )


class GenericTestNode(BaseModel):
    class Config:
        extra = Extra.allow

    test_metadata: TestMetadata
    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType6
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[TestConfig] = Field(
        default_factory=lambda: TestConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": "dbt_test__audit",
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "test",
                "severity": "ERROR",
                "store_failures": None,
                "where": None,
                "limit": None,
                "fail_calc": "count(*)",
                "warn_if": "!= 0",
                "error_if": "!= 0",
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.502492
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )
    column_name: Optional[str] = None
    file_key_name: Optional[str] = None
    attached_node: Optional[str] = None


class SnapshotNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType7
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: SnapshotConfig
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.503581
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )


class SeedNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType8
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[SeedConfig] = Field(
        default_factory=lambda: SeedConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "seed",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "quote_columns": None,
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.504591
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    root_path: Optional[str] = None
    depends_on: Optional[MacroDependsOn] = Field(
        default_factory=lambda: MacroDependsOn.parse_obj({"macros": []})
    )


class FreshnessThreshold(BaseModel):
    class Config:
        extra = Extra.allow

    warn_after: Optional[Time] = Field(
        default_factory=lambda: Time.parse_obj({"count": None, "period": None})
    )
    error_after: Optional[Time] = Field(
        default_factory=lambda: Time.parse_obj({"count": None, "period": None})
    )
    filter: Optional[str] = None


class SourceFreshnessOutput(BaseModel):
    class Config:
        extra = Extra.allow

    unique_id: str
    max_loaded_at: datetime
    snapshotted_at: datetime
    max_loaded_at_time_ago_in_s: float
    status: Status1
    criteria: FreshnessThreshold
    adapter_response: Dict[str, Any]
    timing: List[TimingInfo]
    thread_id: str
    execution_time: float


class ExternalTable(BaseModel):
    class Config:
        extra = Extra.allow

    location: Optional[str] = None
    file_format: Optional[str] = None
    row_format: Optional[str] = None
    tbl_properties: Optional[str] = None
    partitions: Optional[Union[List[str], List[ExternalPartition]]] = None


class Macro(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    resource_type: ResourceType10
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    macro_sql: str
    depends_on: Optional[MacroDependsOn] = Field(
        default_factory=lambda: MacroDependsOn.parse_obj({"macros": []})
    )
    description: Optional[str] = ""
    meta: Optional[Dict[str, Any]] = {}
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    arguments: Optional[List[MacroArgument]] = []
    created_at: Optional[float] = 1682075346.505871
    supported_languages: Optional[List[SupportedLanguage]] = None


class Exposure(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    resource_type: ResourceType12
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    type: Type2
    owner: Owner
    description: Optional[str] = ""
    label: Optional[str] = None
    maturity: Optional[MaturityEnum] = None
    meta: Optional[Dict[str, Any]] = {}
    tags: Optional[List[str]] = []
    config: Optional[ExposureConfig] = Field(
        default_factory=lambda: ExposureConfig.parse_obj({"enabled": True})
    )
    unrendered_config: Optional[Dict[str, Any]] = {}
    url: Optional[str] = None
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    created_at: Optional[float] = 1682075346.50651


class Metric(BaseModel):
    class Config:
        extra = Extra.allow

    name: str
    resource_type: ResourceType13
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    description: str
    label: str
    calculation_method: str
    expression: str
    filters: List[MetricFilter]
    time_grains: List[str]
    dimensions: List[str]
    timestamp: Optional[str] = None
    window: Optional[MetricTime] = None
    model: Optional[str] = None
    model_unique_id: Optional[str] = None
    meta: Optional[Dict[str, Any]] = {}
    tags: Optional[List[str]] = []
    config: Optional[MetricConfig] = Field(
        default_factory=lambda: MetricConfig.parse_obj({"enabled": True, "group": None})
    )
    unrendered_config: Optional[Dict[str, Any]] = {}
    sources: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    refs: Optional[List[RefArgs]] = []
    metrics: Optional[List[List[str]]] = []
    created_at: Optional[float] = 1682075346.507186
    group: Optional[str] = None


class AnalysisNode(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    alias: str
    checksum: FileHash
    config: Optional[NodeConfig] = Field(
        default_factory=lambda: NodeConfig.parse_obj(
            {
                "enabled": True,
                "alias": None,
                "schema": None,
                "database": None,
                "tags": [],
                "meta": {},
                "group": None,
                "materialized": "view",
                "incremental_strategy": None,
                "persist_docs": {},
                "quoting": {},
                "column_types": {},
                "full_refresh": None,
                "unique_key": None,
                "on_schema_change": "ignore",
                "grants": {},
                "packages": [],
                "docs": {"show": True, "node_color": None},
                "contract": {"enforced": False},
                "post-hook": [],
                "pre-hook": [],
            }
        )
    )
    tags: Optional[List[str]] = []
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    group: Optional[str] = None
    docs: Optional[Docs] = Field(
        default_factory=lambda: Docs.parse_obj({"show": True, "node_color": None})
    )
    patch_path: Optional[str] = None
    build_path: Optional[str] = None
    deferred: Optional[bool] = False
    unrendered_config: Optional[Dict[str, Any]] = {}
    created_at: Optional[float] = 1682075346.49809
    config_call_dict: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    raw_code: Optional[str] = ""
    language: Optional[str] = "sql"
    refs: Optional[List[RefArgs]] = []
    sources: Optional[List[List[str]]] = []
    metrics: Optional[List[List[str]]] = []
    depends_on: Optional[DependsOn] = Field(
        default_factory=lambda: DependsOn.parse_obj({"macros": [], "nodes": []})
    )
    compiled_path: Optional[str] = None
    compiled: Optional[bool] = False
    compiled_code: Optional[str] = None
    extra_ctes_injected: Optional[bool] = False
    extra_ctes: Optional[List[InjectedCTE]] = []
    contract: Optional[Contract] = Field(
        default_factory=lambda: Contract.parse_obj(
            {"enforced": False, "checksum": None}
        )
    )


class SourceDefinition(BaseModel):
    class Config:
        extra = Extra.allow

    database: Optional[str] = None
    schema_: str = Field(..., alias="schema")
    name: str
    resource_type: ResourceType9
    package_name: str
    path: str
    original_file_path: str
    unique_id: str
    fqn: List[str]
    source_name: str
    source_description: str
    loader: str
    identifier: str
    quoting: Optional[Quoting] = Field(
        default_factory=lambda: Quoting.parse_obj(
            {"database": None, "schema": None, "identifier": None, "column": None}
        )
    )
    loaded_at_field: Optional[str] = None
    freshness: Optional[FreshnessThreshold] = None
    external: Optional[ExternalTable] = None
    description: Optional[str] = ""
    columns: Optional[Dict[str, ColumnInfo]] = {}
    meta: Optional[Dict[str, Any]] = {}
    source_meta: Optional[Dict[str, Any]] = {}
    tags: Optional[List[str]] = []
    config: Optional[SourceConfig] = Field(
        default_factory=lambda: SourceConfig.parse_obj({"enabled": True})
    )
    patch_path: Optional[str] = None
    unrendered_config: Optional[Dict[str, Any]] = {}
    relation_name: Optional[str] = None
    created_at: Optional[float] = 1682075346.505582


class Model(BaseModel):
    class Config:
        extra = Extra.allow

    metadata: ManifestMetadata = Field(..., description="Metadata about the manifest")
    nodes: Dict[
        str,
        Union[
            AnalysisNode,
            SingularTestNode,
            HookNode,
            ModelNode,
            RPCNode,
            SqlNode,
            GenericTestNode,
            SnapshotNode,
            SeedNode,
        ],
    ] = Field(
        ..., description="The nodes defined in the dbt project and its dependencies"
    )
    sources: Dict[str, SourceDefinition] = Field(
        ..., description="The sources defined in the dbt project and its dependencies"
    )
    macros: Dict[str, Macro] = Field(
        ..., description="The macros defined in the dbt project and its dependencies"
    )
    docs: Dict[str, Documentation] = Field(
        ..., description="The docs defined in the dbt project and its dependencies"
    )
    exposures: Dict[str, Exposure] = Field(
        ..., description="The exposures defined in the dbt project and its dependencies"
    )
    metrics: Dict[str, Metric] = Field(
        ..., description="The metrics defined in the dbt project and its dependencies"
    )
    groups: Dict[str, Group] = Field(
        ..., description="The groups defined in the dbt project"
    )
    selectors: Dict[str, Any] = Field(
        ..., description="The selectors defined in selectors.yml"
    )
    disabled: Optional[
        Dict[
            str,
            List[
                Union[
                    AnalysisNode,
                    SingularTestNode,
                    HookNode,
                    ModelNode,
                    RPCNode,
                    SqlNode,
                    GenericTestNode,
                    SnapshotNode,
                    SeedNode,
                    SourceDefinition,
                    Exposure,
                    Metric,
                ]
            ],
        ]
    ] = Field(None, description="A mapping of the disabled nodes in the target")
    parent_map: Optional[Dict[str, List[str]]] = Field(
        None, description="A mapping from\xa0child nodes to their dependencies"
    )
    child_map: Optional[Dict[str, List[str]]] = Field(
        None, description="A mapping from parent nodes to their dependents"
    )
    group_map: Optional[Dict[str, List[str]]] = Field(
        None, description="A mapping from group names to their nodes"
    )
